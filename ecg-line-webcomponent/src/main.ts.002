namespace ecg {

  const HEIGHT = 125;
  const WIDTH = 275;
  const CURVE_COLOR = "#22ff22";

  let heartData = new Array(100).fill(0);
  let heartDataIndex = 0;
  let beatDataIndex = -1;
  let currentBeatCount = 0;

  const heartRateSchedule = [
    { rate: 50, beats: 10 }, // 60 BPM for 10 beats
    { rate: 100, beats: 10 }, // 80 BPM for 15 beats
    { rate: 300, beats: 10 }, // 120 BPM for 5 beats
    { rate: 0, beats: 2 }, // 120 BPM for 5 beats

    // Add more schedules as needed
  ];
  let scheduleIndex = 0;

  function getNextInterval() {
    const bpm = heartRateSchedule[scheduleIndex].rate;
    return 60000 / bpm; // milliseconds per beat
  }

  function checkScheduleProgress() {
    currentBeatCount++;
    if (currentBeatCount >= heartRateSchedule[scheduleIndex].beats) {
      scheduleIndex = (scheduleIndex + 1) % heartRateSchedule.length;
      currentBeatCount = 0;
    }
  }

  function fillBeatData() {
    const values = [0.1, 0, 0.7, -0.05, -0.8, -0.05, -0.05, 0.15];
    heartData[heartDataIndex] = values[beatDataIndex] || 0;
    beatDataIndex++;
    if (beatDataIndex > 7) {
      beatDataIndex = 0;
    }
  }

  function fillRandomData() {
    heartData[heartDataIndex] = Math.random() * 0.05 - 0.025;
  }

  function updateData() {
    heartDataIndex = (heartDataIndex + 1) % heartData.length;
    if (beatDataIndex >= 0) {
      fillBeatData();
      checkScheduleProgress();
    } else {
      fillRandomData();
    }
  }

  function EcgLine() {
    const self = Reflect.construct(HTMLElement, [], EcgLine);
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    let interval = getNextInterval();

    canvas.height = HEIGHT;
    canvas.width = WIDTH;
    self.appendChild(canvas);

    function onPaint() {
      const baseY = canvas.height / 2;
      const step = (canvas.width - 5) / heartData.length;
      const yFactor = canvas.height * 0.35;
      let heartIndex = (heartDataIndex + 1) % heartData.length;

      context.clearRect(0, 0, canvas.width, canvas.height);
      context.strokeStyle = CURVE_COLOR;
      context.beginPath();
      context.moveTo(0, baseY);

      for (let i = 0; i < heartData.length; i++) {
        const x = i * step;
        const y = baseY - heartData[heartIndex] * yFactor;
        context.lineTo(x, y);
        heartIndex = (heartIndex + 1) % heartData.length;
      }

      context.stroke();
    }

    function updateLoop() {
      updateData();
      onPaint();
      setTimeout(updateLoop, getNextInterval());
    }

    updateLoop();

    return self;
  }

  window['ecgLine'] = EcgLine;
  customElements.define('ecg-line', EcgLine as any);
}
